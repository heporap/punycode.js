/*! https://mths.be/punycode v1.4.0 by @mathias
modified https://github.com/heporap/ v1.0.0 by Wicker Wings @heporap */
!function(a){/*--------------------------------------------------------------------------*/
/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
function b(a){throw new RangeError(F[a])}/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
function c(a,b){for(var c=a.length,d=[];c--;)d[c]=b(a[c]);return d}/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
function d(a,b){var d=a.split("@"),f="",g="";d.length>1&&(f=d[0]+"@",a=d[1]),a=a.replace(E,"."),d=a.match(/^.+?:\/\//),d&&(f=d,a=a.replace(f,""),d=a.split("/"),d.length>1&&(a=d.shift(),g="/"+c(d,function(a){return encodeURIComponent(a)}).join("/"))),a=e(a),a=a.toLowerCase();var h=a.split("."),i=c(h,b).join(".");return f+i+g}/**
	 * adapt for NAMEPREP.
	 * @see RFC3491
	 * @see <https://www.nic.ad.jp/ja/dom/idn.html>
	 * @private
	 * @param {String} string The Unicode input string.
	 * @returns {String} string which is adapted NAMEPREP
	 */
function e(a){
// zenkaku alphabet and digits to hankaku
a=a.replace(/[０-９Ａ-Ｚａ-ｚ]/g,function(a){return String.fromCharCode(a.charCodeAt(0)-65248)});
// Japanese hankaku to zenkaku
var b="ｦｧｨｩｪｫｬｭｮｯｰｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜﾝ".split(""),c="ｶﾞｷﾞｸﾞｹﾞｺﾞｻﾞｼﾞｽﾞｾﾞｿﾞﾀﾞﾁﾞﾂﾞﾃﾞﾄﾞﾊﾞﾋﾞﾌﾞﾍﾞﾎﾞﾊﾟﾋﾟﾌﾟﾍﾟﾎﾟ".match(/../g),d=c.concat(b),e="ガギグゲゴザジズゼゾダヂヅデドバビブベボパピプペポヲァィゥェォャュョッーアイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワン".split(""),f=new RegExp(d.join("|"),"g");return a=a.replace(f,function(a){return e[d.indexOf(a)]})}/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
function f(a){for(var b,c,d=[],e=0,f=a.length;f>e;)b=a.charCodeAt(e++),b>=55296&&56319>=b&&f>e?(c=a.charCodeAt(e++),56320==(64512&c)?d.push(((1023&b)<<10)+(1023&c)+65536):(d.push(b),e--)):d.push(b);return d}/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
function g(a){return c(a,function(a){var b="";return a>65535&&(a-=65536,b+=I(a>>>10&1023|55296),a=56320|1023&a),b+=I(a)}).join("")}/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
function h(a){return 10>a-48?a-22:26>a-65?a-65:26>a-97?a-97:u}/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
function i(a,b){
//  0..25 map to ASCII a..z or A..Z
// 26..35 map to ASCII 0..9
return a+22+75*(26>a)-((0!=b)<<5)}/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
function j(a,b,c){var d=0;for(a=c?H(a/y):a>>1,a+=H(a/b);a>G*w>>1;d+=u)a=H(a/G);return H(d+(G+1)*a/(a+x))}/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
function k(a){
// Don't use UCS-2
var c,d,e,f,i,k,l,m,n,/** Cached calculation results */
o,p=[],q=a.length,r=0,s=A,x=z;for(d=a.lastIndexOf(B),0>d&&(d=0),e=0;d>e;++e)
// if it's not a basic code point
a.charCodeAt(e)>=128&&b("not-basic"),p.push(a.charCodeAt(e));
// Main decoding loop: start just after the last delimiter if any basic code
// points were copied; start at the beginning otherwise.
for(f=d>0?d+1:0;q>f;){
// `index` is the index of the next character to be consumed.
// Decode a generalized variable-length integer into `delta`,
// which gets added to `i`. The overflow checking is easier
// if we increase `i` as we go, then subtract off its starting
// value at the end to obtain `delta`.
for(i=r,k=1,l=u;f>=q&&b("invalid-input"),m=h(a.charCodeAt(f++)),(m>=u||m>H((t-r)/k))&&b("overflow"),r+=m*k,n=x>=l?v:l>=x+w?w:l-x,!(n>m);l+=u)o=u-n,k>H(t/o)&&b("overflow"),k*=o;c=p.length+1,x=j(r-i,c,0==i),
// `i` was supposed to wrap around from `out` to `0`,
// incrementing `n` each time, so we'll fix that now:
H(r/c)>t-s&&b("overflow"),s+=H(r/c),r%=c,
// Insert `n` at position `i` of the output
p.splice(r++,0,s)}return g(p)}/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
function l(a){var c,d,e,g,h,k,l,m,n,o,p,/** `inputLength` will hold the number of code points in `input`. */
q,/** Cached calculation results */
r,s,x,y=[];
// Handle the basic code points
for(a=f(a),q=a.length,c=A,d=0,h=z,k=0;q>k;++k)p=a[k],128>p&&y.push(I(p));
// Main encoding loop:
for(e=g=y.length,
// `handledCPCount` is the number of code points that have been handled;
// `basicLength` is the number of basic code points.
// Finish the basic string - if it is not empty - with a delimiter
g&&y.push(B);q>e;){
// All non-basic code points < n have been handled already. Find the next
// larger one:
for(l=t,k=0;q>k;++k)p=a[k],p>=c&&l>p&&(l=p);for(r=e+1,l-c>H((t-d)/r)&&b("overflow"),d+=(l-c)*r,c=l,k=0;q>k;++k)if(p=a[k],c>p&&++d>t&&b("overflow"),p==c){
// Represent delta as a generalized variable-length integer
for(m=d,n=u;o=h>=n?v:n>=h+w?w:n-h,!(o>m);n+=u)x=m-o,s=u-o,y.push(I(i(o+x%s,0))),m=H(x/s);y.push(I(i(m,0))),h=j(d,r,e==g),d=0,++e}++d,++c}return y.join("")}/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
function m(a){return d(a,function(a){return C.test(a)?k(a.slice(4).toLowerCase()):a})}/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
function n(a){return d(a,function(a){return D.test(a)?"xn--"+l(a):a})}/** Detect free variables */
var o="object"==typeof exports&&exports&&!exports.nodeType&&exports,p="object"==typeof module&&module&&!module.nodeType&&module,q="object"==typeof global&&global;(q.global===q||q.window===q||q.self===q)&&(a=q);/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
var r,/** Temporary variable */
s,/** Highest positive signed 32-bit float value */
t=2147483647,// aka. 0x7FFFFFFF or 2^31-1
/** Bootstring parameters */
u=36,v=1,w=26,x=38,y=700,z=72,A=128,// 0x80
B="-",// '\x2D'
/** Regular expressions */
C=/^xn--/,D=/[^\x20-\x7E]/,// unprintable ASCII chars + non-ASCII chars
E=/[\x2E\u3002\uFF0E\uFF61]/g,// RFC 3490 separators
/** Error messages */
F={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},/** Convenience shortcuts */
G=u-v,H=Math.floor,I=String.fromCharCode;/** Expose `punycode` */
// Some AMD build optimizers, like r.js, check for specific condition patterns
// like the following:
if(r={/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
version:"1.3.2",/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
ucs2:{decode:f,encode:g},decode:k,encode:l,toASCII:n,toUnicode:m},"function"==typeof define&&"object"==typeof define.amd&&define.amd)define("punycode",function(){return r});else if(o&&p)if(module.exports==o)
// in Node.js, io.js, or RingoJS v0.8.0+
p.exports=r;else
// in Narwhal or RingoJS v0.7.0-
for(s in r)r.hasOwnProperty(s)&&(o[s]=r[s]);else
// in Rhino or a web browser
a.punycode=r}(this);